# 10. 内核态中断处理

本章和接下来的一章研究 xv6 中最有趣的主题之一: **内核态和用户态的切换**. 回忆一下, xv6 内核工作在 **S 模式**, 而用户进程工作在 **U 模式**. 我们知道, 在 RISC-V 中, 导致处理器特权模式从 U (低级别) 切换到 S (高级别) 的唯一机制是 **中断**. 因此, 不难得出以下论断:
* 从用户态进入内核态, 意味着发生了 **中断**
* 从内核态回到用户态, 意味着 **中断返回**

> 第 3 章中讨论的时钟中断是一个特例. 甚至不能在 S 模式中处理时钟中断, 而必须进入 M 模式.

即使在内核态, 中断也有可能发生. 在本章中, 我们首先讨论 **内核态中发生中断** 该怎么处理. 这是因为处理用户态中产生的中断涉及 **从用户态到内核态的陷入**, 从而更加复杂. 后一种情况将是下一章的主题.

## RISC-V 硬件对中断的支持

和之前讨论过的虚拟内存机制一样, 中断处理离不开硬件的支持. 在第 2、3 章中, 我们已经初步介绍过 RISC-V 处理器响应中断的过程. 在这里, 我们给出一个更加正式、完整的描述. 我们假设处理器一开始处于 S 或 U 模式.

1. 处理器每执行完一条指令, 便检查是否需要响应中断. 处理器会对每一类中断作如下检查:
    * 如果该中断是 **内中断** (即指令本身产生的中断) 且中断码为 i, 那么检查 `medeleg` 的第 i 位. 根据这一位为 0 或为 1, 处理器决定陷入 **M 模式** 或 **S 模式** 以处理中断.
    * 如果该中断是 **外中断** (外部设备产生的中断) 且中断码为 i, 那么
        + 首先检查 `mideleg` 的第 i 位. 根据这一位为 0 或为 1, 处理器判断该中断的级别为 **M 级别** 或 **S 级别**. 
            > 此时处理器还不一定决定 **响应中断**, 因为还需检查中断开关.
        + 根据中断的级别为 M/S, 确认 `mstatus`/`sstatus` 中的 MIE/SIE 位为 1, 且 `mie`/`sie` 的第 i 位为 1. 如果两个位都为 1, 说明 **中断开关** 处于开启, 执行下一步; 否则, 不响应中断.
        + 检查 `mip`/`sip` 的第 i 位. 如果为 1, 说明有中断待处理; 根据中断的级别为 M/S, 处理器决定陷入 **M 模式** 或 **S 模式** 以处理中断. 否则, 不响应中断.

        如果确实有待处理的外中断, 则处理器可以通过 `mip`/`sip` 中为 1 的位确定其类型.

> 我们看到, RISC-V 处理器对待内中断和外中断有许多不同之处:
> * 可以通过中断开关 "关闭" 外中断, 但不能 "关闭" 内中断. 这是因为, 内中断往往来源于处理器 "取值-执行" 循环中的故障; 如果不响应内中断, 处理器根本无法按正常的指令流执行下去.
> * 外中断到来时, `mip`/`sip` 寄存器会 "提醒" CPU 有待处理的外中断. 对于内中断则无这样的寄存器.
>
> 不过, 内、外中断的区别只存在于 "处理器决定是否响应中断" 这一步. 等到实际处理中断的时候, 两者就不再区别对待.

假定在第 1 步中, 处理器 **决定陷入 X 模式** (X 为 M/S) 处理中断. 那么处理器接下来就完成一些例行公事: 

2. 将当前处理器特权级别存入 `xstatus` 寄存器的 XPP 字段, 然后将特权级别切换为 X.
3. 将 `xstatus` 中的 XIE 位保存到 XPIE 位, 然后令 XIE 位为 0. 这样, 我们在 X 模式下 **关闭所有外中断**.
4. 填写 `xcause` 寄存器. 该寄存器用于向软件 (操作系统) 报告中断原因.
    * 对于外中断/内中断, `xcause` 的最高位分别填 1/0.
    * `xcause` 的剩余位填入中断码.
5. 对于内中断, 如果产生了错误码, 则将错误码填入 `xtval` 寄存器.
6. 把当前 `pc` 存入 `xepc` 寄存器.
7. 把 `xtvec` 寄存器的值复制到 `pc`.
> 这里我们假设 `mtvec`/`stvec` 中存有 4 字节对齐的地址. RISC-V 还允许在第 6 步中根据不同的中断码将 `pc` 设置为不同的地址, 但是 xv6 不使用这一特性.

在这里, 6、7 两步合称为 **交换中断向量**, 其效果是使程序的正常执行被打断, CPU 跳转到地址 `mtvec`/`stvec` 处的指令接着执行.

通过上面的描述, 我们看到: 中断处理最初的工作是由 **硬件** 完成的. 这些工作是 **共性的**; 也就是说, 不论发生什么种类的中断, 硬件都执行一模一样的步骤. 针对不同种类的中断作出 **个性化的** 处理, 是 **软件 (操作系统)** 的工作. 具体来讲, 操作系统应该:
* 事先编写好中断处理程序. 在系统启动时, 将处理程序的 **入口地址** 写入 `mtvec`/`stvec` 寄存器.
* 在中断处理程序中, 根据 `mcause`/`scause`, `mtval`/`stval` 判断中断的类型和原因, 并跳转到合适的分支执行具体的中断处理工作.
* 处理完成后, 使用 **`mret`/`sret` 指令** 回到正常指令流.

本章的剩余部分及下一章将介绍 xv6 如何配合硬件完成中断处理的工作.

> RISC-V 中, `xret` 指令 (`x` 为 `m`/`s`) 会导致处理器做如下工作:
> * 将 `xstatus` 中的 XIE 位设为 XPIE 位存储的值, 然后令 XPIE 为 1.
> * 特权级别被设为 `xstatus` 中 XPP 字段的值, 然后把 XPP 字段清零.
> * 把 `xepc` 中的值复制到 `pc`.
> 
> 这样, 处理器会回到 **中断发生时刚执行完的那条指令** 重新开始执行.

## Recap: 时钟中断处理

在 xv6 中, 对时钟中断的处理不同于其他种类的中断. 这是因为时钟中断是唯一需要 **陷入到 M 模式** 才能处理的中断. 在第 3 章中, 我们已详细介绍过 xv6 对时钟中断的处理流程. 我们在此简要总结如下:
* 在 xv6 启动时, 通过 `timerinit()` 函数完成时钟中断处理的初始化:
    + 为每个 CPU 核心分配 40 字节物理内存, 其中存放有 **该核心的 `mtimecmp` 寄存器的内存映射地址**, 以及 **每两次时钟中断相隔的周期数** 等重要信息. 将这 40 字节内存的基址存入 `mscratch` 寄存器.
    + 将函数 `timervec()` (定义在 `kernel/kernelvec.S[93:124]`) 的首地址存入 `mtvec` 寄存器.
* 时钟中断发生时, 硬件跳转到 `timervec()` 函数. 它完成以下工作:
    + 修改 `mtimecmp` 寄存器的值, 以设定下一次时钟中断发生的时间.
    + 修改 `sip` 寄存器的值为 `0x2`, 从而向 S 模式 **转发** 一个 supervisor software interrupt (SSI, 中断码为 1 的外中断).
    + 使用 `mret` 指令返回 U 或 S 模式.

    值得注意的是, `timervec()` 本身只完成尽可能少的工作, 而把更复杂的处理 **转交给 S 模式下的 SSI 中断处理函数** 完成.

一般来讲, 为了处理任何一种中断, 通常需要编写两个函数:
* **中断处理初始化函数**. 类似于 `timerinit()`, 这个函数在系统启动时执行, 为中断处理做准备 (设置有关寄存器, 在内存中维护必要的数据结构, 等等).
* **中断处理函数**. 类似于 `timervec()`, 它是实际处理中断的函数.

在本章的剩余部分中, 我们将看看 xv6 如何对 **时钟中断以外的中断** 完成以上两部分的工作.

## xv6 中断处理初始化

在 `main()` 函数中, 通过调用 `trapinit()` 和 `trapinithart()` 来完成中断处理的初始化工作: (`kernel/main.c[23:24]`)
```c
    trapinit();      // trap vectors
    trapinithart();  // install kernel trap vector
```
这两个函数的定义分别在 `kernel/trap.c[19:23]` 和 `kernel/trap.c[25:30]`:
```c
void trapinit(void)
{
  initlock(&tickslock, "time");
}

void trapinithart(void)
{
  w_stvec((uint64)kernelvec);
}
```
`trapinit()` 和 `trapinithart()` 完成的工作很简单: 前者初始化了一个互斥锁 `tickslock`; 后者把 `kernelvec()` 函数的首地址存入 `stvec` 寄存器. 

> 为什么不让 `trapinit()` 和 `trapinithart()` 做更多的工作呢 (就像 `timerinit()` 那样)? 事实上, `timerinit()` 肩负着 **初始化时钟设备** 和 **初始化 M 模式中断处理** 的两重任务. 如果按照严格的模块化设计, `timerinit()` **本该拆成两个函数**, 其中一个在内存中为每个 CPU 维护 40 字节的区域 (对应前一任务), 另一个设置 `mtvec`, `mstatus`, `mie` 等寄存器 (对应后一任务). 
>
> 之所以把这两个任务放在同一个函数中, 是由于时钟中断是 **唯一** 需要在 M 模式中处理的中断. 但是对于 S 模式下的中断处理 (也就是我们现在关心的), 情况并非如此. 因此 xv6 决定让 `trapinit()` 和 `trapinithart()` 只完成共性的工作, 而把依赖于设备细节的初始化工作放到每个设备各自的初始化函数中.

## xv6 内核态中断处理函数: `kernelvec()`

在 xv6 的中断处理初始化代码中 (具体来说, 是 `trapinithart()` 函数中), 我们将 `kernelvec()` 的首地址放入了 `stvec` 寄存器. 因此, `kernelvec()` 函数就是 **内核态下的中断处理函数**. 我们现在就来研究它的实现. 

`kernelvec()` 函数是用汇编语言写的, 定义在 `kernel/kernelvec.S[10:88]`:
```asm
.globl kernelvec
.align 4
kernelvec:
    # make room to save registers.
    addi sp, sp, -256

    # save the registers.
    sd ra, 0(sp)
    sd sp, 8(sp)
    sd gp, 16(sp)
    sd tp, 24(sp)
    sd t0, 32(sp)
    sd t1, 40(sp)
    sd t2, 48(sp)
    sd s0, 56(sp)
    sd s1, 64(sp)
    sd a0, 72(sp)
    sd a1, 80(sp)
    sd a2, 88(sp)
    sd a3, 96(sp)
    sd a4, 104(sp)
    sd a5, 112(sp)
    sd a6, 120(sp)
    sd a7, 128(sp)
    sd s2, 136(sp)
    sd s3, 144(sp)
    sd s4, 152(sp)
    sd s5, 160(sp)
    sd s6, 168(sp)
    sd s7, 176(sp)
    sd s8, 184(sp)
    sd s9, 192(sp)
    sd s10, 200(sp)
    sd s11, 208(sp)
    sd t3, 216(sp)
    sd t4, 224(sp)
    sd t5, 232(sp)
    sd t6, 240(sp)

    # call the C trap handler in trap.c
    call kerneltrap

    # restore registers.
    ld ra, 0(sp)
    ld sp, 8(sp)
    ld gp, 16(sp)
    # not tp (contains hartid), in case we moved CPUs
    ld t0, 32(sp)
    ld t1, 40(sp)
    ld t2, 48(sp)
    ld s0, 56(sp)
    ld s1, 64(sp)
    ld a0, 72(sp)
    ld a1, 80(sp)
    ld a2, 88(sp)
    ld a3, 96(sp)
    ld a4, 104(sp)
    ld a5, 112(sp)
    ld a6, 120(sp)
    ld a7, 128(sp)
    ld s2, 136(sp)
    ld s3, 144(sp)
    ld s4, 152(sp)
    ld s5, 160(sp)
    ld s6, 168(sp)
    ld s7, 176(sp)
    ld s8, 184(sp)
    ld s9, 192(sp)
    ld s10, 200(sp)
    ld s11, 208(sp)
    ld t3, 216(sp)
    ld t4, 224(sp)
    ld t5, 232(sp)
    ld t6, 240(sp)

    addi sp, sp, 256

    # return to whatever we were doing in the kernel.
    sret
```
这个函数实际上并不涉及中断处理的具体逻辑, 它只是简单地 **保存现场**. 具体来说, 这个函数
* 将 RISC-V 的所有通用寄存器 (除恒为零的 `zero` 外, 一共 31 个) 全部保存到栈上
* 调用 C 语言编写的 `kerneltrap()` 函数
* 当 `kerneltrap()` 返回时, 将 **除 `tp` 外的** 所有通用寄存器值从栈上恢复
* 用 `sret` 指令返回到正常控制流

> 在第三步中, 为什么不从栈上恢复 `tp` 的值呢? 我们把这个问题的详细分析留到第 11 章中. 不过, 我们在此指出: 这是为了保证 **内核态下 `tp == mhartid` 恒成立**.

