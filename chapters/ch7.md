# 7. 内核态虚拟内存

从本章开始, 我们的主题是 **虚拟内存**. 简单来讲, 虚拟内存是一种对物理内存进行 **抽象** 的机制. 一旦启用这种机制后, 当 CPU 执行一条访问地址 X 的访存指令时, 并不会直接访问物理地址为 X 的存储单元, 而是先通过一种特殊的硬件 (**内存管理单元**, 或 **MMU**) 将地址 X 翻译为另一个地址 Y, 然后访问物理地址为 Y 的存储单元. 在这里, 地址 X 就叫做 **虚拟地址**.

虚拟内存机制为程序员提供了一个简洁的编程模型: 从应用程序的角度看来, 程序中的访存指令是在访问一个虚构的 **虚拟地址空间**, 而非真正的物理内存. 此外, 操作系统对内存的管理和保护也依赖于虚拟内存机制.

## RISC-V 地址翻译硬件

虚拟内存机制依赖于硬件提供的 **地址翻译** 功能. 所谓地址翻译, 是指把一个虚拟地址 X 翻译成物理地址 Y. 在 RISC-V 特权指令集手册 ([https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf](https://riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf), 4.3 至 4.5 节) 中, 介绍了 RISC-V 支持的三种地址翻译模式: Sv32, Sv39 和 Sv48.

xv6 操作系统使用 RISC-V 的 **Sv39** 地址翻译模式作为虚拟内存机制的硬件支持. 在接下来的几段中, 我们将介绍 Sv39 模式下的地址翻译流程. 

Sv39 模式下, 虚拟地址的长度为 39 位, 物理地址的长度为 56 位. 这意味着一个合法的 64 位虚拟地址中的高 25 位都必须为 0. 为了支持地址翻译, 虚拟地址空间和物理地址空间都被划分为一系列 4096 ($2^{12}$) 字节的 **页**. 相应地, 虚拟地址和物理地址都被划分为 **页号** (page number, PN) 和 **页偏移** (page offset), 如下图所示:

![Sv39 模式下的虚拟地址和物理地址](/chapters/ch7-figs/address.png "Sv39 模式下的虚拟地址和物理地址")

虚拟地址和物理地址的低 12 位代表页偏移, 其余位代表页号. 页号 (VPN 或 PPN) 又进一步分成三个部分.

### 地址翻译过程

**页表** 记录了虚拟页号 (VPN) 到物理页号 (PPN) 的映射. 粗略地来说, 地址翻译过程就是:
* 给定一个虚拟地址 X, 取出它的 VPN
* 在页表中, 找到序号为 VPN 的条目, 从中读出 PPN
* 把虚拟地址 X 的 VPN 改成 PPN, 即得物理地址 Y

页表本身也需要存放在内存中. 在 RISC-V 中, 使用 `satp` 寄存器保存页表的起始物理地址. 在 32 位和 64 位机器上, `satp` 寄存器的结构分别如下面两张图所示:

![RV32 下的 satp 寄存器](/chapters/ch7-figs/satp32.png "RV32 下的 satp 寄存器")

![RV64 下的 satp 寄存器](/chapters/ch7-figs/satp64.png "RV64 下的 satp 寄存器")

我们只需要关心第二张图, 因为只有 64 位 RISC-V 机器才支持 Sv39 翻译模式. 在 64 位机器上, `satp` 的低 44 位代表 **页表所在的物理页号 (PPN)**. 将这个页号乘以一页的大小 (4096 字节), 就得到 **页表的起始物理地址**.

此外, `satp` 的头 4 位表示地址翻译模式. 当这 4 位的值为 8 时, 表示 Sv39 模式.

![RV64 支持的地址翻译模式](/chapters/ch7-figs/modes.png "RV64 支持的地址翻译模式")

当然, 实际的地址翻译过程比这要复杂一些. 主要原因是: Sv39 模式下 VPN 一共有 27 位; 如果按照上面的方式来做地址翻译, 那么我们需要 $2^{27}$ 个页表项. 为了减少页表项的内存占用, 实际的 Sv39 模式使用 **多级页表** (共有 3 级) 来帮助地址翻译:

* 给定一个虚拟地址 X, 取出它的 `VPN[2]`
* 在 **一级页表** 中 (基址为 `satp[0:43] * 4096` 字节), 找到序号为 `VPN[2]` 的条目, 读出该条目的 PPN, 设为 `p0`
* 取出地址 X 的 `VPN[1]`, 然后在 **二级页表** 中 (基址为 `p0 * 4096` 字节), 找到序号为 `VPN[1]` 的条目, 读出该条目的 PPN, 设为 `p1`
* 取出地址 X 的 `VPN[0]`, 然后在 **三级页表** 中 (基址为 `p1 * 4096` 字节), 找到序号为 `VPN[0]` 的条目, 读出该条目的 PPN, 设为 `p2`
* 把虚拟地址 X 的 VPN 改为 `p2`, 即得物理地址 Y

> 以上地址翻译过程中, 只有 `p2` 是虚拟地址 X 真正对应的物理页号. 物理页号 `p0` 或 `p1` 表达的含义是: 在 `p0` 或 `p1` 所指示的物理页中, 存放着下一级 (二级或三级) 页表. 通常把对应于某个虚拟页的物理页 (例如 PPN 为 `p2` 的物理页) 叫做 **叶子页**, 而把对应于某个二级/三级页表的物理页 (例如 PPN 为 `p0` 或 `p1` 的物理页) 叫做 **页表页**.

### 页表的结构

在 Sv39 模式下, 无论是一级、二级还是三级页表, 都是由一系列 8 字节的表项组成的. 每个表项的内容如下图所示:

![Sv39 模式下的页表项](/chapters/ch7-figs/pte.png "Sv39 模式下的页表项")

> 因为 `VPN[0]`, `VPN[1]` 和 `VPN[2]` 都是 9 位长的, 所以每一级页表都有 $2^9$ 个表项, 其大小正好是 $2^{12}$ 字节, 即一个页的大小.

页表项中除了地址翻译过程所需要的 PPN (长度 44 位) 之外, 还有一系列 **权限检查位**:
* `V` 位表示该页表项是 (1) / 否 (0) 有效. 如果硬件在地址翻译过程中查询到了一条无效的页表项, 则会终止翻译, 并触发一个缺页异常.
* `R`, `W`, `X` 位分别表示该页表项指向的物理页是 (1) / 否 (0) 是 **可读的**, **可写的** 或 **可执行的**. 如果该页表项的 PPN 对应于一个 **叶子页**, 那么 `R`, `W`, `X` 三位至少有一位是 1. 如果这三位都为 0, 那么表示该页表项的 PPN 是某个 **页表页** 的物理页号. 具体如下图所示:

![R, W, X 位的含义](/chapters/ch7-figs/rwx.png "R, W, X 位的含义")

* `U` 位表示该页表项指向的物理页是 (1) / 否 (0) 可在用户模式 (U 模式) 访问.
* `A` 位又叫 **访问位** (access bit). 它表示: 自 `A` 位上一次被清零以来, 该页表项对应的物理页是 (1) / 否 (0) 被访问过. (访问包括读、写或执行.)
* `D` 位又叫 **脏位** (dirty bit). 它表示: 自 `D` 位上一次被清零以来, 该页表项对应的物理页是 (1) / 否 (0) 被写过.

> `U`, `A`, `D` 位都只对 **叶子页** 生效. 页表页的 `U`, `A`, `D` 位必须总是清零.

有了这些权限位之后, 地址翻译流程还需要增加对这些权限位的检查:

* 访问一个叶子页之前, 必须根据处理器特权级别、访存指令的类型, 检查此次访问是否符合指向该页的页表项中 `R`, `W`, `X`, `U` 位的限制.
* 成功访问一个 `A=0` 的叶子页后, 须令指向该页的页表项中 `A` 位为 1.
* 成功写一个 `D=0` 的叶子页后, 须令指向该页的页表项中 `D` 位为 1.

> 硬件保证: 同一次地址翻译过程中, 读取叶子页页表项, 与写页表项中的 `A`, `D` 位, 这两步操作是原子的. 也就是说, 不会在两步之间插入不属于本次地址翻译过程的读或写.

## 内核态虚拟内存的初始化

现在我们来看 xv6 内核如何 **为自身** 启用虚拟内存机制. 这部分代码位于 `kernel/main.c[20:21]`:
```c
    kvminit();       // create kernel page table
    kvminithart();   // turn on paging
```
一旦完成这部分工作, 我们就可以使用 **虚拟地址** (而非物理地址) 来访问内核中的数据结构.

从上一节可以看到, 地址翻译过程并不需要操作系统的过多参与——硬件会自动地完成这一切. 操作系统要做的其实只有三件事:
* 在内存中建立并维护页表
* 设置 `satp` 寄存器以控制地址翻译
* 当缺页中断发生时, 做出处理

在这三条当中, 第三条涉及中断处理, 因而我们在此不做赘述. (第 10~11 章会更仔细地介绍中断处理这个主题.) 本章的剩余部分将介绍 xv6 内核如何完成前两条的工作.

### xv6 内核态虚拟地址空间

xv6 内核通过 `kvminit()` 函数为内核建立页表. 这个函数定义在 `kernel/vm.c[52:57]`:
```c
// Initialize the one kernel_pagetable
void kvminit(void)
{
  kernel_pagetable = kvmmake();
}
```
它调用 `kvmmake()` 生成内核页表, 然后将它保存在全局变量 `kernel_pagetable` 中. 全局变量 `kernel_pagetable` 定义在 `kernel/vm.c[12]`:
```c
pagetable_t kernel_pagetable;
```
它的数据类型定义在 `kernel/riscv.h[330:331]`:
```c
typedef uint64 pte_t;
typedef uint64 *pagetable_t;
```
在这里, 类型 `pte_t` 代表一个 8 字节长的页表项, `pagetable_t` 代表一个页表 (页表项的数组).

> 为什么不需要保护共享数据 `kernel_pagetable` 呢? 这是因为 `kvminit()` 函数仅被编号为 0 的 CPU 独自调用一次. 除了 `kvminit()` 初始化了 `kernel_pagetable` 的值之外, 没有任何函数会修改 `kernel_pagetable`. 即 `kernel_pagetable` 实际上是只读常量.

在开始研究建立页表的细节之前, 描绘一些 big picture 是有帮助的. 从逻辑上讲, "建立页表" 的过程, 实质上是建立了一个 **虚拟地址空间**, 然后按照地址翻译的规则建立从虚拟地址空间到物理地址空间的 **映射**. 怎么样建立虚拟地址空间, 从原则上来说是任意的; 此外, 虚拟地址空间可能远比物理地址空间大, 因此我们也允许多个虚拟地址对应同一个物理地址. 

xv6 内核采用一种非常简单的方式来构建虚拟地址空间:
* 对于虚拟地址范围 `[0, 0x88000000)`, 采用 **直接映射**, 也就是令 **物理地址 = 虚拟地址**.
* 将虚拟地址空间最顶部的一页 (称为 **trampoline 页**) 映射到物理内存中内核代码段地址最高的一页. 这一页中包含了从用户态陷入内核态, 以及从内核态返回用户态时必须执行的代码. (之所以做这样的映射, 是为了方便中断处理.)
* 在 trampoline 页下方, 为每个进程分配一个虚拟页作为 **内核栈**. 这些内核栈对应的物理页通过 `kalloc()` 从空闲物理内存中分配出来.

下面这张图取自 xv6 book. 它很好地展示了 xv6 内核态虚拟内存的布局, 以及虚拟地址空间到物理地址空间的映射关系.

![xv6 内核态虚拟地址空间布局](/chapters/ch7-figs/addrspace.png "xv6 内核态虚拟地址空间布局")

### 页表的建立

现在我们来阅读 xv6 内核建立页表的代码细节. 



